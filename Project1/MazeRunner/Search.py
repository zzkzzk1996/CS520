import queue
import math
import copy


def DFS(maze):
    """
    :param mp: the input maze generated by Maze
    :return: if the Maze is solvable, return the path, if not ,return False
    """
    mp = copy.deepcopy(maze)
    stack = []
    # start from the upper point
    current_state = [0, 0]
    dim = len(mp)
    stack.append(current_state)
    mp[0][0] = 1
    i = current_state[0]
    j = current_state[1]
    while ([i, j] != [dim - 1, dim - 1]):
        if (j + 1) < dim and mp[i][j + 1] == 0:
            stack.append([i, (j + 1)])
            mp[i][j + 1] = 1
            j = j + 1
            # current_state[1] = j
        elif (i + 1) < dim and mp[i + 1][j] == 0:
            stack.append([i + 1, j])
            mp[i + 1][j] = 1
            i = i + 1
            # current_state[0] = i
        elif (j - 1) >= 0 and mp[i][j - 1] == 0:
            stack.append([i, j - 1])
            mp[i][j - 1] = 1
            j = j - 1
            # current_state[1] = j
        elif (i - 1) >= 0 and mp[i - 1][j] == 0:
            stack.append([i - 1, j])
            mp[i - 1][j] = 1
            i = i - 1
            # current_state[0] = i
        else:
            if len(stack) > 1:
                stack.pop()
                i = stack[-1][0]
                j = stack[-1][1]
            else:
                return []
    return stack


def BFS(maze):
    """
    :param maze: the input maze generated by Maze
    :return: if the Maze is solvable, return the path, if not ,return False
    """
    mp = copy.deepcopy(maze)
    queue = []
    pre = dict()
    pre[0, 0] = [-1, -1]
    dim = len(mp)
    mp[0][0] = 1
    i = 0
    j = 0
    while ([i, j] != [dim - 1, dim - 1]):
        if (j + 1) < dim and mp[i][j + 1] == 0:
            queue.append([i, (j + 1)])
            pre[i, j + 1] = [i, j]
            mp[i][j + 1] = 1
            if [i, j + 1] == [dim - 1, dim - 1]:
                pre[dim - 1, dim - 1] = [i, j]
                break
        if (i + 1) < dim and mp[i + 1][j] == 0:
            queue.append([i + 1, j])
            pre[i + 1, j] = [i, j]
            mp[i + 1][j] = 1
            if [i + 1, j] == [dim - 1, dim - 1]:
                pre[dim - 1, dim - 1] = [i, j]
                break
        if (j - 1) >= 0 and mp[i][j - 1] == 0:
            queue.append([i, j - 1])
            pre[i, j - 1] = [i, j]
            mp[i][j - 1] = 1
            if [i, j - 1] == [dim - 1, dim - 1]:
                pre[dim - 1, dim - 1] = [i, j]
                break
        if (i - 1) >= 0 and mp[i - 1][j] == 0:
            queue.append([i - 1, j])
            pre[i - 1, j] = [i, j]
            mp[i - 1][j] = 1
            if [i - 1, j] == [dim - 1, dim - 1]:
                pre[dim - 1, dim - 1] = [i, j]
                break
        if len(queue) > 0:
            cur = queue.pop(0)
            i = cur[0]
            j = cur[1]
        else:
            return []

    key = (dim - 1, dim - 1)
    path = list()
    path.append(key)
    while key != (0, 0):
        item = tuple(pre.get(key))
        path.append(item)
        key = item
    path.reverse()
    return path


def A_star_Euc(Maze):
    dim = len(Maze)
    open_pq = queue.PriorityQueue()
    close = list()
    cur = [0, 0]
    goal = [dim - 1, dim - 1]
    open_pq.put((euc_heuristc(cur, goal), [0, 0]))
    parent = dict()
    while open_pq.qsize() > 0:
        cur = open_pq.get()[1]
        close.append(copy.deepcopy(cur))
        i, j = cur[0], cur[1]
        if cur == goal:
            break
        if j + 1 < dim and Maze[i][j + 1] != 1:
            flag = find_priority([i, j + 1], open_pq)
            if [i, j + 1] not in close and not flag:
                parent[i, j + 1] = [i, j]
                hx = 1 + euc_heuristc([i, j + 1], goal)
                gx = track_cost([i, j + 1], parent)
                open_pq.put((hx + gx, [i, j + 1]))
        if i + 1 < dim and Maze[i + 1][j] != 1:
            flag = find_priority([i + 1, j], open_pq)
            if [i + 1, j] not in close and not flag:
                parent[i + 1, j] = [i, j]
                hx = 1 + euc_heuristc([i + 1, j], goal)
                gx = track_cost([i + 1, j], parent)
                open_pq.put((hx + gx, [i + 1, j]))
        if j - 1 >= 0 and Maze[i][j - 1] != 1:
            flag = find_priority([i, j - 1], open_pq)
            if [i, j - 1] not in close and not flag:
                parent[i, j - 1] = [i, j]
                hx = 1 + euc_heuristc([i, j - 1], goal)
                gx = track_cost([i, j - 1], parent)
                open_pq.put((hx + gx, [i, j - 1]))
        if i - 1 >= 0 and Maze[i - 1][j] != 1:
            flag = find_priority([i - 1, j], open_pq)
            if [i - 1, j] not in close and not flag:
                parent[i - 1, j] = [i, j]
                hx = 1 + euc_heuristc([i - 1, j], goal)
                gx = track_cost([i - 1, j], parent)
                open_pq.put((hx + gx, [i - 1, j]))
    if tuple(goal) in parent.keys():
        path = track_path(goal, parent)
        return path
    else:
        return []


def A_star_Man(Maze):
    dim = len(Maze)
    open_pq = queue.PriorityQueue()
    close = list()
    cur = [0, 0]
    goal = [dim - 1, dim - 1]
    open_pq.put((euc_heuristc(cur, goal), [0, 0]))
    parent = dict()
    while open_pq.qsize() > 0:
        cur = open_pq.get()[1]
        close.append(copy.deepcopy(cur))
        i, j = cur[0], cur[1]
        if cur == goal:
            break
        if j + 1 < dim and Maze[i][j + 1] != 1:
            flag = find_priority([i, j + 1], open_pq)
            if [i, j + 1] not in close and not flag:
                parent[i, j + 1] = [i, j]
                hx = 1 + man_heuristc([i, j + 1], goal)
                gx = track_cost([i, j + 1], parent)
                open_pq.put((hx + gx, [i, j + 1]))
        if i + 1 < dim and Maze[i + 1][j] != 1:
            flag = find_priority([i + 1, j], open_pq)
            if [i + 1, j] not in close and not flag:
                parent[i + 1, j] = [i, j]
                hx = 1 + man_heuristc([i + 1, j], goal)
                gx = track_cost([i + 1, j], parent)
                open_pq.put((hx + gx, [i + 1, j]))
        if j - 1 >= 0 and Maze[i][j - 1] != 1:
            flag = find_priority([i, j - 1], open_pq)
            if [i, j - 1] not in close and not flag:
                parent[i, j - 1] = [i, j]
                hx = 1 + man_heuristc([i, j - 1], goal)
                gx = track_cost([i, j - 1], parent)
                open_pq.put((hx + gx, [i, j - 1]))
        if i - 1 >= 0 and Maze[i - 1][j] != 1:
            flag = find_priority([i - 1, j], open_pq)
            if [i - 1, j] not in close and not flag:
                parent[i - 1, j] = [i, j]
                hx = 1 + man_heuristc([i - 1, j], goal)
                gx = track_cost([i - 1, j], parent)
                open_pq.put((hx + gx, [i - 1, j]))
    if tuple(goal) in parent.keys():
        path = track_path(goal, parent)
        return path
    else:
        return []


def euc_heuristc(current_state, goal_state):
    d = math.sqrt(pow((goal_state[0] - current_state[0]), 2) + pow((goal_state[1] - current_state[1]), 2))
    return d


def man_heuristc(current_state, goal_state):
    d = abs(goal_state[0] - current_state[0]) + abs(goal_state[1] - current_state[1])
    return d

def track_cost(current, parent):
    i = 0
    current = tuple(current)
    while current != (0, 0):
        current = tuple(parent.get(current))
        i = i + 1
    return i


def track_path(current, parent):
    path = list()
    current = tuple(current)
    path.append(current)
    while current != (0, 0):
        pre = tuple(parent.get(current))
        path.append(pre)
        current = pre

    path.reverse()
    return path


def find_priority(cur, pq):
    if len(pq.queue) == 0:
        return False
    else:
        for item in pq.queue:
            if item[1] == cur:
                return True
            else:
                return False

