def DFS(Maze):
    """
    :param Maze: the input maze generated by Maze
    :return: if the Maze is solvable, return the path, if not ,return False
    """
    stack = []
    # start from the upper point
    current_state = [0, 0]
    dim = len(Maze)
    stack.append(current_state)
    Maze[0][0] = 1
    i = current_state[0]
    j = current_state[1]
    while ([i, j] != [dim - 1, dim - 1]):
        if (j + 1) < dim and Maze[i][j + 1] == 0:
            stack.append([i, (j + 1)])
            Maze[i][j + 1] = 1
            j = j + 1
            # current_state[1] = j
        elif (i + 1) < dim and Maze[i + 1][j] == 0:
            stack.append([i + 1, j])
            Maze[i + 1][j] = 1
            i = i + 1
            # current_state[0] = i
        elif (j - 1) >= 0 and Maze[i][j - 1] == 0:
            stack.append([i, j - 1])
            Maze[i][j - 1] = 1
            j = j - 1
            # current_state[1] = j
        elif (i - 1) >= 0 and Maze[i - 1][j] == 0:
            stack.append([i - 1, j])
            Maze[i - 1][j] = 1
            i = i - 1
            # current_state[0] = i
        else:
            if len(stack) > 0:
                tmp = stack.pop()
                i = tmp[0]
                j = tmp[1]
            else:
                return False
    return stack


def BFS(Maze):
    """
    :param Maze: the input maze generated by Maze
    :return: if the Maze is solvable, return the path, if not ,return False
    """
    queue = []
    pre = []
    pre.append([0, 0])
    dim = len(Maze)
    Maze[0][0] = 1
    i = 0
    j = 0
    while ([i, j] != [dim - 1, dim - 1]):
        if (j + 1) < dim and Maze[i][j + 1] == 0:
            queue.append([i, (j + 1)])
            Maze[i][j + 1] = 1
            if [i, j + 1] == [dim - 1, dim - 1]:
                pre.append([i, j + 1])
                break
        if (i + 1) < dim and Maze[i + 1][j] == 0:
            queue.append([i + 1, j])
            Maze[i + 1][j] = 1
            if [i + 1, j] == [dim - 1, dim - 1]:
                pre.append([i + 1, j])
                break
        if (j - 1) >= 0 and Maze[i][j - 1] == 0:
            queue.append([i, j - 1])
            Maze[i][j - 1] = 1
            if [i, j - 1] == [dim - 1, dim - 1]:
                pre.append([dim - 1, dim - 1])
                break
        if (i - 1) >= 0 and Maze[i - 1][j] == 0:
            queue.append([i - 1, j])
            Maze[i - 1][j] = 1
            if [i - 1, j] == [dim - 1, dim - 1]:
                pre.append([dim - 1, dim - 1])
                break
        if len(queue) > 0:
            cur = queue.pop(0)
            i = cur[0]
            j = cur[1]
            pre.append([i, j])
        else:
            return False
    return pre
